C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE EX86
OBJECT MODULE PLACED IN ex86.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ex86.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //将按键次数写入AT24C08，再读出并用1602LCD显示
   2          #include<reg52.h>       //包含单片机寄存器的头文件
   3          #include<intrins.h>     //包含_nop_()函数定义的头文件
   4          sbit RS=P2^0;           //寄存器选择位，将RS位定义为P2.0引脚
   5          sbit RW=P2^1;           //读写选择位，将RW位定义为P2.1引脚
   6          sbit E=P2^2;            //使能信号位，将E位定义为P2.2引脚
   7          sbit BF=P0^7;           //忙碌标志位，，将BF位定义为P0.7引脚
   8          sbit K5=P1^4;            //将S位定义为P1.4引脚
   9          #define OP_READ 0xa1    // 器件地址以及读取操作,0xa1即为1010 0001B
  10          #define OP_WRITE 0xa0   // 器件地址以及写入操作,0xa1即为1010 0000B
  11          sbit SDA=P3^5;          //将串行数据总线SDA位定义在为P3.5引脚
  12          sbit SCL=P3^4;          //将串行时钟总线SDA位定义在为P3.4引脚
  13          unsigned char code digit[ ]={"0123456789"}; //定义字符数组显示数字
  14          unsigned char code string[ ]={"24C08 RW-TEST"}; //定义字符数组显示提示信息
  15          /*****************************************************
  16          函数功能：延时1ms
  17          (3j+2)*i=(3×33+2)×10=1010(微秒)，可以认为是1毫秒
  18          ***************************************************/
  19          void delay1ms()
  20          {
  21   1         unsigned char i,j;   
  22   1               for(i=0;i<10;i++)
  23   1                for(j=0;j<33;j++)
  24   1                 ;             
  25   1       }
  26          /*****************************************************
  27          函数功能：延时若干毫秒
  28          入口参数：n
  29          ***************************************************/
  30           void delaynms(unsigned char n)
  31           {
  32   1         unsigned char i;
  33   1              for(i=0;i<n;i++)
  34   1                 delay1ms();
  35   1       }
  36          /*******************************************************************************
  37          以下是对液晶模块的操作程序
  38          ********************************************************************************/
  39          /*****************************************************
  40          函数功能：判断液晶模块的忙碌状态
  41          返回值：result。result=1，忙碌;result=0，不忙
  42          ***************************************************/
  43           unsigned char BusyTest(void)
  44            {
  45   1          bit result;
  46   1              RS=0;       //根据规定，RS为低电平，RW为高电平时，可以读状态
  47   1          RW=1;
  48   1          E=1;        //E=1，才允许读写
  49   1          _nop_();   //空操作
  50   1          _nop_();
  51   1          _nop_(); 
  52   1          _nop_();   //空操作四个机器周期，给硬件反应时间     
  53   1          result=BF;  //将忙碌标志电平赋给result
  54   1         E=0;         //将E恢复低电平
  55   1         return result;
C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 2   

  56   1        }
  57          /*****************************************************
  58          函数功能：将模式设置指令或显示地址写入液晶模块
  59          入口参数：dictate
  60          ***************************************************/
  61          void WriteInstruction (unsigned char dictate)
  62          {   
  63   1          while(BusyTest()==1);   //如果忙就等待
  64   1               RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
  65   1               RW=0;   
  66   1               E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
  67   1                                  // 就是让E从0到1发生正跳变，所以应先置"0"
  68   1               _nop_();
  69   1               _nop_();               //空操作两个机器周期，给硬件反应时间
  70   1               P0=dictate;            //将数据送入P0口，即写入指令或地址
  71   1               _nop_();
  72   1               _nop_();
  73   1               _nop_();
  74   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  75   1               E=1;                   //E置高电平
  76   1               _nop_();
  77   1               _nop_();
  78   1               _nop_();
  79   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  80   1                E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
  81   1       }
  82          /*****************************************************
  83          函数功能：指定字符显示的实际地址
  84          入口参数：x
  85          ***************************************************/
  86           void WriteAddress(unsigned char x)
  87           {
  88   1           WriteInstruction(x|0x80); //显示位置的确定方法规定为"80H+地址码x"
  89   1       }
  90          /*****************************************************
  91          函数功能：将数据(字符的标准ASCII码)写入液晶模块
  92          入口参数：y(为字符常量)
  93          ***************************************************/
  94           void WriteData(unsigned char y)
  95           {
  96   1          while(BusyTest()==1);  
  97   1                RS=1;           //RS为高电平，RW为低电平时，可以写入数据
  98   1                RW=0;
  99   1                E=0;            //E置低电平(根据表8-6，写指令时，E为高脉冲，
 100   1                             // 就是让E从0到1发生正跳变，所以应先置"0"
 101   1                P0=y;           //将数据送入P0口，即将数据写入液晶模块
 102   1                _nop_();
 103   1                _nop_();
 104   1                _nop_();
 105   1           _nop_();       //空操作四个机器周期，给硬件反应时间
 106   1                E=1;          //E置高电平
 107   1                _nop_();
 108   1                _nop_();
 109   1                _nop_();
 110   1               _nop_();        //空操作四个机器周期，给硬件反应时间
 111   1               E=0;            //当E由高电平跳变成低电平时，液晶模块开始执行命令
 112   1       }
 113          /*****************************************************
 114          函数功能：对LCD的显示模式进行初始化设置
 115          ***************************************************/
 116          void LcdInitiate(void)
 117          {
C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 3   

 118   1          delaynms(15);               //延时15ms，首次写指令时应给LCD一段较长的反应时间
 119   1          WriteInstruction(0x38);     //显示模式设置：16×2显示，5×7点阵，8位数据接口
 120   1              delaynms(5);                //延时5ms　，给硬件一点反应时间
 121   1          WriteInstruction(0x38);
 122   1              delaynms(5);
 123   1              WriteInstruction(0x38);     //连续三次，确保初始化成功
 124   1              delaynms(5);
 125   1              WriteInstruction(0x0c);     //显示模式设置：显示开，无光标，光标不闪烁
 126   1              delaynms(5);
 127   1              WriteInstruction(0x06);     //显示模式设置：光标右移，字符不移
 128   1              delaynms(5);
 129   1              WriteInstruction(0x01);     //清屏幕指令，将以前的显示内容清除
 130   1              delaynms(5);
 131   1      
 132   1       }
 133           /***************************************************
 134           函数功能：显示小时                          
 135          ***************************************************/
 136          void Display(unsigned char x)
 137          {
 138   1         unsigned char i,j;
 139   1              i=x/10;                  //取整运算，求得十位数字
 140   1              j=x%10;                  //取余运算，求得各位数字
 141   1          WriteAddress(0x47);      //写显示地址，将十位数字显示在第2行第7列
 142   1              WriteData(digit[i]);     //将十位数字的字符常量写入LCD
 143   1              WriteData(digit[j]);     //将个位数字的字符常量写入LCD
 144   1           
 145   1       }
 146          /*******************************************************************************
 147          以下是对AT24C02的读写操作程序
 148          ********************************************************************************/
 149          /***************************************************
 150          函数功能：开始数据传送
 151          ***************************************************/
 152          void start()
 153          // 开始位
 154          {
 155   1              SDA = 1;    //SDA初始化为高电平“1”
 156   1              SCL = 1;    //开始数据传送时，要求SCL为高电平“1”
 157   1              _nop_();    //等待一个机器周期
 158   1              _nop_();    //等待一个机器周期
 159   1              SDA = 0;    //SDA的下降沿被认为是开始信号
 160   1              _nop_();    //等待一个机器周期
 161   1              _nop_();    //等待一个机器周期
 162   1              _nop_();    //等待一个机器周期
 163   1              _nop_();    //等待一个机器周期
 164   1              SCL = 0;    //SCL为低电平时，SDA上数据才允许变化(即允许以后的数据传递）
 165   1      }
 166          /***************************************************
 167          函数功能：结束数据传送
 168          ***************************************************/
 169          void stop()
 170          // 停止位
 171          {
 172   1              SDA = 0;     //SDA初始化为低电平“0”
 173   1              _nop_();     //等待一个机器周期
 174   1              _nop_();     //等待一个机器周期
 175   1              SCL = 1;     //结束数据传送时，要求SCL为高电平“1”
 176   1              _nop_();     //等待一个机器周期
 177   1              _nop_();     //等待一个机器周期
 178   1              _nop_();     //等待一个机器周期
 179   1              _nop_();     //等待一个机器周期
C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 4   

 180   1              SDA = 1;    //SDA的上升沿被认为是结束信号
 181   1      }
 182          /***************************************************
 183          函数功能：从AT24Cxx读取数据
 184          出口参数：x
 185          ***************************************************/
 186          unsigned char ReadData()
 187          // 从AT24Cxx移入数据到MCU
 188          {
 189   1              unsigned char i;
 190   1              unsigned char x;   //储存从AT24Cxx中读出的数据
 191   1              for(i = 0; i < 8; i++)
 192   1              {
 193   2                      SCL = 1;                //SCL置为高电平
 194   2                      x<<=1;                  //将x中的各二进位向左移一位
 195   2                      x|=(unsigned char)SDA;  //将SDA上的数据通过按位“或“运算存入x中
 196   2                      SCL = 0;                        //在SCL的下降沿读出数据
 197   2              }
 198   1              return(x);                //将读取的数据返回
 199   1      }
 200          /***************************************************
 201          函数功能：向AT24Cxx的当前地址写入数据
 202          入口参数：y (储存待写入的数据）
 203          ***************************************************/
 204          //在调用此数据写入函数前需首先调用开始函数start(),所以SCL=0
 205          bit WriteCurrent(unsigned char y)
 206          {
 207   1              unsigned char i;
 208   1              bit ack_bit;               //储存应答位
 209   1              for(i = 0; i < 8; i++)          // 循环移入8个位
 210   1              {
 211   2              SDA = (bit)(y&0x80);   //通过按位“与”运算将最高位数据送到S
 212   2                                                        //因为传送时高位在前，低位在后
 213   2                      _nop_();            //等待一个机器周期   
 214   2                 SCL = 1;            //在SCL的上升沿将数据写入AT24Cxx      
 215   2              _nop_();            //等待一个机器周期 
 216   2                _nop_();             //等待一个机器周期       
 217   2                      
 218   2                      SCL = 0;            //将SCL重新置为低电平，以在SCＬ线形成传送数据所需的８个脉冲
 219   2                      y <<= 1;           //将y中的各二进位向左移一位
 220   2              }
 221   1              SDA = 1;                          // 发送设备（主机）应在时钟脉冲的高电平期间(SCL=1)释放SDA线，
 222   1                              //以让SDA线转由接收设备(AT24Cxx)控制
 223   1              _nop_();        //等待一个机器周期 
 224   1              _nop_();        //等待一个机器周期 
 225   1              SCL = 1;       //根据上述规定，SCL应为高电平
 226   1              _nop_();       //等待一个机器周期 
 227   1              _nop_();       //等待一个机器周期 
 228   1              _nop_();       //等待一个机器周期 
 229   1              _nop_();       //等待一个机器周期 
 230   1              ack_bit = SDA; //接受设备（AT24Cxx)向SDA送低电平，表示已经接收到一个字节
 231   1                             //若送高电平，表示没有接收到，传送异常
 232   1              SCL = 0;       //SCL为低电平时，SDA上数据才允许变化(即允许以后的数据传递）
 233   1              return  ack_bit;                        // 返回AT24Cxx应答位
 234   1      }
 235          /***************************************************
 236          函数功能：向AT24Cxx中的指定地址写入数据
 237          入口参数：add (储存指定的地址）；dat(储存待写入的数据）
 238          ***************************************************/
 239          void WriteSet(unsigned char add, unsigned char dat)
 240          // 在指定地址addr处写入数据WriteCurrent
 241          {
C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 5   

 242   1              start();               //开始数据传递
 243   1              WriteCurrent(OP_WRITE);  //选择要操作的AT24Cxx芯片，并告知要对其写入数据
 244   1              WriteCurrent(add);       //写入指定地址
 245   1              WriteCurrent(dat);       //向当前地址（上面指定的地址）写入数据
 246   1              stop();                //停止数据传递
 247   1              delaynms(4);           //1个字节的写入周期为1ms, 最好延时1ms以上
 248   1      }
 249          /***************************************************
 250          函数功能：从AT24Cxx中的当前地址读取数据
 251          出口参数：x (储存读出的数据） 
 252          ***************************************************/
 253          unsigned char ReadCurrent()
 254          {
 255   1              unsigned char x;
 256   1              start();               //开始数据传递
 257   1              WriteCurrent(OP_READ);   //选择要操作的AT24Cxx芯片，并告知要读其数据
 258   1              x=ReadData();         //将读取的数据存入x
 259   1              stop();                //停止数据传递
 260   1              return x;              //返回读取的数据
 261   1      }
 262          /***************************************************
 263          函数功能：从AT24Cxx中的指定地址读取数据
 264          入口参数：set_add
 265          出口参数：x 
 266          ***************************************************/
 267          unsigned char ReadSet(unsigned char set_add)
 268          // 在指定地址读取
 269          {
 270   1              start();                      //开始数据传递
 271   1              WriteCurrent(OP_WRITE);       //选择要操作的AT24Cxx芯片，并告知要对其写入数据
 272   1              WriteCurrent(set_add);       //写入指定地址
 273   1              return(ReadCurrent());        //从指定地址读出数据并返回
 274   1      }
 275          /*********************************************************************
 276          函数功能：主函数
 277          ***********************************************************************/
 278           void main(void)
 279           {
 280   1          unsigned char sum;    //储存计数值
 281   1               unsigned char x;      //储存从AT24C08读出的值
 282   1                unsigned char i;
 283   1          LcdInitiate();        //调用LCD初始化函数  
 284   1               sum=0;                //将计数值初始化为0
 285   1                WriteAddress(0x01);    //写地址，从第1行第4列开始显示
 286   1               i=0;              //从字符数组的第1个元素开始显示
 287   1               while(string[i]!='\0')   //只要没有显示到字符串的结束标志'\0'，就继续
 288   1               {
 289   2                       WriteData(string[i]); //将第i个字符数组元素写入LCD
 290   2                       i++;                 //指向下一个数组元素
 291   2               }
 292   1          while(1)             //无限循环
 293   1            {
 294   2                        if(K5==0)          //如果该键被按下
 295   2                         {
 296   3                          delaynms(80);   //软件消抖，延时80ms
 297   3                               if(K5==0)        //确实该键被按下
 298   3                                sum++;         //计件值加1
 299   3                                while(!K5);     //等待按键释放
 300   3                               if(sum==99)     //如果计满99
 301   3                                sum=0;         //清0，重新开始计数
 302   3                              }
 303   2             WriteSet(0x10,sum); //将计件值写入AT24C02中的指定地址"0x10"
C51 COMPILER V8.02   EX86                                                                  07/24/2009 11:32:31 PAGE 6   

 304   2                       x=ReadSet(0x10);    //从AT24C02中读出计件值
 305   2                       Display(x);          //将计件值用1602LCD显示
 306   2                }
 307   1      }
 308          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    422    ----
   CONSTANT SIZE    =     25    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
