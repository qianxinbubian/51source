C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE EX90
OBJECT MODULE PLACED IN ex90.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ex90.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //实例90：DS18B20温度检测及其液晶显示
   2          #include<reg51.h>    //包含单片机寄存器的头文件
   3          #include<intrins.h>  //包含_nop_()函数定义的头文件
   4          unsigned char code digit[10]={"0123456789"};     //定义字符数组显示数字
   5          unsigned char code Str[]={"Test by DS18B20"};    //说明显示的是温度
   6          unsigned char code Error[]={"Error!Check!"};     //说明没有检测到DS18B20
   7          unsigned char code Temp[]={"Temp:"};             //说明显示的是温度
   8          unsigned char code Cent[]={"Cent"};              //温度单位
   9          /*******************************************************************************
  10          以下是对液晶模块的操作程序
  11          *******************************************************************************/
  12          sbit RS=P2^0;           //寄存器选择位，将RS位定义为P2.0引脚
  13          sbit RW=P2^1;           //读写选择位，将RW位定义为P2.1引脚
  14          sbit E=P2^2;            //使能信号位，将E位定义为P2.2引脚
  15          sbit BF=P0^7;           //忙碌标志位，，将BF位定义为P0.7引脚
  16          /*****************************************************
  17          函数功能：延时1ms
  18          (3j+2)*i=(3×33+2)×10=1010(微秒)，可以认为是1毫秒
  19          ***************************************************/
  20          void delay1ms()
  21          {
  22   1         unsigned char i,j;   
  23   1               for(i=0;i<4;i++)
  24   1                for(j=0;j<33;j++)
  25   1                 ;             
  26   1       }
  27          /*****************************************************
  28          函数功能：延时若干毫秒
  29          入口参数：n
  30          ***************************************************/
  31           void delaynms(unsigned char n)
  32           {
  33   1         unsigned char i;
  34   1              for(i=0;i<n;i++)
  35   1                 delay1ms();
  36   1       }
  37          /*****************************************************
  38          函数功能：判断液晶模块的忙碌状态
  39          返回值：result。result=1，忙碌;result=0，不忙
  40          ***************************************************/
  41          bit BusyTest(void)
  42            {
  43   1          bit result;
  44   1              RS=0;       //根据规定，RS为低电平，RW为高电平时，可以读状态
  45   1          RW=1;
  46   1          E=1;        //E=1，才允许读写
  47   1          _nop_();   //空操作
  48   1          _nop_();
  49   1          _nop_(); 
  50   1          _nop_();   //空操作四个机器周期，给硬件反应时间     
  51   1          result=BF;  //将忙碌标志电平赋给result
  52   1         E=0;         //将E恢复低电平
  53   1         return result;
  54   1        }
  55          /*****************************************************
C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 2   

  56          函数功能：将模式设置指令或显示地址写入液晶模块
  57          入口参数：dictate
  58          ***************************************************/
  59          void WriteInstruction (unsigned char dictate)
  60          {   
  61   1          while(BusyTest()==1);   //如果忙就等待
  62   1               RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
  63   1               RW=0;   
  64   1               E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
  65   1                                 // 就是让E从0到1发生正跳变，所以应先置"0"
  66   1               _nop_();
  67   1               _nop_();               //空操作两个机器周期，给硬件反应时间
  68   1               P0=dictate;            //将数据送入P0口，即写入指令或地址
  69   1               _nop_();
  70   1               _nop_();
  71   1               _nop_();
  72   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  73   1               E=1;                   //E置高电平
  74   1               _nop_();
  75   1               _nop_();
  76   1               _nop_();
  77   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  78   1                E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
  79   1       }
  80          /*****************************************************
  81          函数功能：指定字符显示的实际地址
  82          入口参数：x
  83          ***************************************************/
  84           void WriteAddress(unsigned char x)
  85           {
  86   1           WriteInstruction(x|0x80); //显示位置的确定方法规定为"80H+地址码x"
  87   1       }
  88          /*****************************************************
  89          函数功能：将数据(字符的标准ASCII码)写入液晶模块
  90          入口参数：y(为字符常量)
  91          ***************************************************/
  92           void WriteData(unsigned char y)
  93           {
  94   1          while(BusyTest()==1);  
  95   1                RS=1;           //RS为高电平，RW为低电平时，可以写入数据
  96   1                RW=0;
  97   1                E=0;            //E置低电平(根据表8-6，写指令时，E为高脉冲，
  98   1                           // 就是让E从0到1发生正跳变，所以应先置"0"
  99   1                P0=y;           //将数据送入P0口，即将数据写入液晶模块
 100   1                _nop_();
 101   1                _nop_();
 102   1                _nop_();
 103   1           _nop_();       //空操作四个机器周期，给硬件反应时间
 104   1                E=1;           //E置高电平
 105   1                _nop_();
 106   1                _nop_();
 107   1                _nop_();
 108   1               _nop_();        //空操作四个机器周期，给硬件反应时间
 109   1               E=0;            //当E由高电平跳变成低电平时，液晶模块开始执行命令
 110   1       }
 111          /*****************************************************
 112          函数功能：对LCD的显示模式进行初始化设置
 113          ***************************************************/
 114          void LcdInitiate(void)
 115          {
 116   1          delaynms(15);               //延时15ms，首次写指令时应给LCD一段较长的反应时间
 117   1          WriteInstruction(0x38);     //显示模式设置：16×2显示，5×7点阵，8位数据接口
C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 3   

 118   1              delaynms(5);                //延时5ms　，给硬件一点反应时间
 119   1          WriteInstruction(0x38);
 120   1              delaynms(5);               //延时5ms　，给硬件一点反应时间
 121   1              WriteInstruction(0x38);     //连续三次，确保初始化成功
 122   1              delaynms(5);               //延时5ms　，给硬件一点反应时间
 123   1              WriteInstruction(0x0c);     //显示模式设置：显示开，无光标，光标不闪烁
 124   1              delaynms(5);               //延时5ms　，给硬件一点反应时间
 125   1              WriteInstruction(0x06);     //显示模式设置：光标右移，字符不移
 126   1              delaynms(5);                //延时5ms　，给硬件一点反应时间
 127   1              WriteInstruction(0x01);     //清屏幕指令，将以前的显示内容清除
 128   1              delaynms(5);             //延时5ms　，给硬件一点反应时间
 129   1      
 130   1       } 
 131          /************************************************************************
 132          以下是DS18B20的操作程序
 133           ************************************************************************/ 
 134          sbit DQ=P3^3;
 135          unsigned char time;   //设置全局变量，专门用于严格延时
 136          /*****************************************************
 137          函数功能：将DS18B20传感器初始化，读取应答信号
 138          出口参数：flag 
 139          ***************************************************/
 140          bit Init_DS18B20(void)  
 141          {
 142   1       bit flag;         //储存DS18B20是否存在的标志，flag=0，表示存在；flag=1，表示不存在
 143   1       DQ = 1;           //先将数据线拉高
 144   1       for(time=0;time<2;time++) //略微延时约6微秒
 145   1           ;
 146   1       DQ = 0;           //再将数据线从高拉低，要求保持480~960us
 147   1       for(time=0;time<200;time++)  //略微延时约600微秒
 148   1           ;         //以向DS18B20发出一持续480~960us的低电平复位脉冲 
 149   1       DQ = 1;           //释放数据线（将数据线拉高） 
 150   1        for(time=0;time<10;time++)
 151   1           ;  //延时约30us（释放总线后需等待15~60us让DS18B20输出存在脉冲）
 152   1       flag=DQ;          //让单片机检测是否输出了存在脉冲（DQ=0表示存在）      
 153   1       for(time=0;time<200;time++)  //延时足够长时间，等待存在脉冲输出完毕
 154   1            ;
 155   1       return (flag);    //返回检测成功标志
 156   1      }
 157          /*****************************************************
 158          函数功能：从DS18B20读取一个字节数据
 159          出口参数：dat
 160          ***************************************************/ 
 161          unsigned char ReadOneChar(void)
 162           {
 163   1                      unsigned char i=0;      
 164   1                      unsigned char dat;  //储存读出的一个字节数据
 165   1                      for (i=0;i<8;i++)
 166   1                       {
 167   2                         
 168   2                         DQ =1;       // 先将数据线拉高
 169   2                         _nop_();         //等待一个机器周期   
 170   2                         DQ = 0;      //单片机从DS18B20读书据时,将数据线从高拉低即启动读时序
 171   2                              dat>>=1;
 172   2                         _nop_();     //等待一个机器周期                 
 173   2                         DQ = 1;     //将数据线"人为"拉高,为单片机检测DS18B20的输出电平作准备
 174   2                         for(time=0;time<2;time++)
 175   2                   ;      //延时约6us，使主机在15us内采样
 176   2                         if(DQ==1)
 177   2                            dat|=0x80;  //如果读到的数据是1，则将1存入dat
 178   2                              else
 179   2                                      dat|=0x00;//如果读到的数据是0，则将0存入dat
C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 4   

 180   2                           //将单片机检测到的电平信号DQ存入r[i]       
 181   2                         for(time=0;time<8;time++)
 182   2                              ;              //延时3us,两个读时序之间必须有大于1us的恢复期    
 183   2                  }                       
 184   1               return(dat);    //返回读出的十进制数据
 185   1      }
 186          /*****************************************************
 187          函数功能：向DS18B20写入一个字节数据
 188          入口参数：dat
 189          ***************************************************/  
 190          WriteOneChar(unsigned char dat)
 191          {
 192   1              unsigned char i=0;
 193   1              for (i=0; i<8; i++)
 194   1                       {
 195   2                        DQ =1;         // 先将数据线拉高
 196   2                        _nop_();           //等待一个机器周期  
 197   2                        DQ=0;          //将数据线从高拉低时即启动写时序       
 198   2                        DQ=dat&0x01;   //利用与运算取出要写的某位二进制数据,
 199   2                             //并将其送到数据线上等待DS18B20采样      
 200   2                       for(time=0;time<10;time++)     
 201   2                           ;//延时约30us，DS18B20在拉低后的约15~60us期间从数据线上采样
 202   2                        DQ=1;          //释放数据线               
 203   2                        for(time=0;time<1;time++)
 204   2                                ;//延时3us,两个写时序间至少需要1us的恢复期
 205   2                        dat>>=1;       //将dat中的各二进制位数据右移1位
 206   2                       }
 207   1                for(time=0;time<4;time++)
 208   1                            ; //稍作延时,给硬件一点反应时间
 209   1      }
 210          /******************************************************************************
 211          以下是与温度有关的显示设置
 212           ******************************************************************************/
 213           /*****************************************************
 214          函数功能：显示没有检测到DS18B20
 215          ***************************************************/   
 216          void display_error(void)
 217           {
 218   1             unsigned char i;
 219   1                           WriteAddress(0x00);    //写显示地址，将在第1行第1列开始显示
 220   1                                 i = 0;                //从第一个字符开始显示
 221   1                                      while(Error[i] != '\0')  //只要没有写到结束标志，就继续写
 222   1                                      {                                               
 223   2                                              WriteData(Error[i]);   //将字符常量写入LCD
 224   2                                              i++;                 //指向下一个字符
 225   2                                              delaynms(100);        //延时100ms较长时间，以看清关于显示的说明
 226   2                                      }       
 227   1                                      while(1)              //进入死循环，等待查明原因
 228   1                                        ;
 229   1      }
 230          /*****************************************************
 231          函数功能：显示说明信息
 232          ***************************************************/   
 233          void display_explain(void)
 234           {
 235   1             unsigned char i;
 236   1                           WriteAddress(0x00);    //写显示地址，将在第1行第1列开始显示
 237   1                                 i = 0;                //从第一个字符开始显示
 238   1                                      while(Str[i] != '\0')  //只要没有写到结束标志，就继续写
 239   1                                      {                                               
 240   2                                              WriteData(Str[i]);   //将字符常量写入LCD
 241   2                                              i++;                 //指向下一个字符
C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 5   

 242   2                                              delaynms(100);        //延时100ms较长时间，以看清关于显示的说明
 243   2                                      }       
 244   1      }
 245          /*****************************************************
 246          函数功能：显示温度符号
 247          ***************************************************/   
 248          void display_symbol(void)
 249           {
 250   1             unsigned char i;
 251   1                           WriteAddress(0x40);    //写显示地址，将在第2行第1列开始显示
 252   1                                 i = 0;                //从第一个字符开始显示
 253   1                                      while(Temp[i] != '\0')  //只要没有写到结束标志，就继续写
 254   1                                      {                                               
 255   2                                              WriteData(Temp[i]);   //将字符常量写入LCD
 256   2                                              i++;                 //指向下一个字符
 257   2                                              delaynms(50);        //延时1ms给硬件一点反应时间
 258   2                                      }       
 259   1      }
 260          
 261          /*****************************************************
 262          函数功能：显示温度的小数点
 263          ***************************************************/   
 264          void    display_dot(void)
 265          {         
 266   1               WriteAddress(0x49);      //写显示地址，将在第2行第10列开始显示            
 267   1               WriteData('.');      //将小数点的字符常量写入LCD
 268   1               delaynms(50);         //延时1ms给硬件一点反应时间              
 269   1      }
 270          /*****************************************************
 271          函数功能：显示温度的单位(Cent)
 272          ***************************************************/   
 273          void    display_cent(void)
 274          {
 275   1                 unsigned char i;    
 276   1                           WriteAddress(0x4c);        //写显示地址，将在第2行第13列开始显示   
 277   1                                 i = 0;                    //从第一个字符开始显示 
 278   1                                      while(Cent[i] != '\0')     //只要没有写到结束标志，就继续写
 279   1                                      {                                       
 280   2                                              WriteData(Cent[i]);     //将字符常量写入LCD
 281   2                                              i++;                 //指向下一个字符
 282   2                                              delaynms(50);        //延时1ms给硬件一点反应时间
 283   2                                      }       
 284   1      }
 285          /*****************************************************
 286          函数功能：显示温度的整数部分
 287          入口参数：x
 288          ***************************************************/ 
 289          void display_temp1(unsigned char x)
 290          {
 291   1       unsigned char j,k,l;     //j,k,l分别储存温度的百位、十位和个位
 292   1              j=x/100;              //取百位
 293   1              k=(x%100)/10;    //取十位
 294   1              l=x%10;             //取个位  
 295   1              WriteAddress(0x46);    //写显示地址,将在第2行第7列开始显示
 296   1              WriteData(digit[j]);    //将百位数字的字符常量写入LCD
 297   1              WriteData(digit[k]);    //将十位数字的字符常量写入LCD
 298   1              WriteData(digit[l]);    //将个位数字的字符常量写入LCD
 299   1              delaynms(50);         //延时1ms给硬件一点反应时间     
 300   1       }
 301           /*****************************************************
 302          函数功能：显示温度的小数数部分
 303          入口参数：x
C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 6   

 304          ***************************************************/ 
 305           void display_temp2(unsigned char x)
 306          {
 307   1              WriteAddress(0x4a);      //写显示地址,将在第2行第11列开始显示
 308   1              WriteData(digit[x]);     //将小数部分的第一位数字字符常量写入LCD
 309   1              delaynms(50);          //延时1ms给硬件一点反应时间
 310   1      }
 311          /*****************************************************
 312          函数功能：做好读温度的准备
 313          ***************************************************/ 
 314          void ReadyReadTemp(void)
 315          {
 316   1            Init_DS18B20();     //将DS18B20初始化
 317   1                      WriteOneChar(0xCC); // 跳过读序号列号的操作
 318   1                      WriteOneChar(0x44); // 启动温度转换       
 319   1                 for(time=0;time<100;time++)
 320   1                          ;    //温度转换需要一点时间
 321   1                      Init_DS18B20();     //将DS18B20初始化
 322   1                      WriteOneChar(0xCC); //跳过读序号列号的操作
 323   1                      WriteOneChar(0xBE); //读取温度寄存器,前两个分别是温度的低位和高位       
 324   1      }
 325          
 326          
 327          /*****************************************************
 328          函数功能：主函数
 329          ***************************************************/ 
 330          
 331           void main(void)
 332           {        
 333   1                unsigned char TL;     //储存暂存器的温度低位
 334   1           unsigned char TH;    //储存暂存器的温度高位
 335   1           unsigned char TN;      //储存温度的整数部分
 336   1                unsigned char TD;       //储存温度的小数部分
 337   1                LcdInitiate();         //将液晶初始化
 338   1                 delaynms(5);        //延时5ms给硬件一点反应时间      
 339   1                      if(Init_DS18B20()==1)
 340   1                  display_error();
 341   1                      display_explain();
 342   1              display_symbol();    //显示温度说明
 343   1            display_dot();       //显示温度的小数点
 344   1            display_cent();      //显示温度的单位
 345   1         while(1)                //不断检测并显示温度
 346   1               {      
 347   2                      ReadyReadTemp();     //读温度准备
 348   2                 TL=ReadOneChar();    //先读的是温度值低位
 349   2                      TH=ReadOneChar();    //接着读的是温度值高位
 350   2                      TN=TH*16+TL/16;      //实际温度值=(TH*256+TL)/16,即：TH*16+TL/16
 351   2                                                //这样得出的是温度的整数部分,小数部分被丢弃了
 352   2                 TD=(TL%16)*10/16;    //计算温度的小数部分,将余数乘以10再除以16取整，
 353   2                                                //这样得到的是温度小数部分的第一位数字(保留1位小数)
 354   2                 display_temp1(TN);    //显示温度的整数部分
 355   2                 display_temp2(TD);    //显示温度的小数部分
 356   2            delaynms(10);               
 357   2          }   
 358   1                                
 359   1      }
 360          
 361          
 362          
 363          
 364          

C51 COMPILER V8.02   EX90                                                                  06/24/2009 16:13:01 PAGE 7   


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    625    ----
   CONSTANT SIZE    =     50    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
