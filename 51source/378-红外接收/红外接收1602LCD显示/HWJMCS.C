//本解码程序适用于NEC的upd6121及其兼容芯片的解码，支持大多数遥控器 实验板采用11.0592MHZ晶振
#include<reg52.h>       //包含单片机寄存器的头文件
#include<intrins.h>  //包含_nop_()函数定义的头文件
sbit IR=P3^2;           //将IR位定义为P3.2引脚
sbit RS=P2^0;    //寄存器选择位，将RS位定义为P2.0引脚
sbit RW=P2^1;    //读写选择位，将RW位定义为P2.1引脚
sbit E=P2^2;     //使能信号位，将E位定义为P2.2引脚
sbit BF=P0^7;    //忙碌标志位，，将BF位定义为P0.7引脚
sbit BEEP = P3^6; //蜂鸣器控制端口P36 
unsigned char flag;
unsigned char code string[ ]= {"1602IR-CODE TEST"}; 
unsigned char a[4];    //储存用户码、用户反码与键数据码、键数据反码
unsigned int LowTime,HighTime; //储存高、低电平的宽度 
/*****************************************************
函数功能：延时1ms
***************************************************/
void delay1ms()
{
   unsigned char i,j;	
	 for(i=0;i<10;i++)
	  for(j=0;j<33;j++)
	   ;		 
 }
 /*****************************************************
函数功能：延时若干毫秒
入口参数：n
***************************************************/
 void delay(unsigned char n)
 {
   unsigned char i;
	for(i=0;i<n;i++)
	   delay1ms();
 }



/*********************************************************/
void beep()		//蜂鸣器响一声函数
{
  unsigned char i;
  for (i=0;i<100;i++)
   {
   delay1ms();
   BEEP=!BEEP;       //BEEP取反
   } 
   BEEP=1;           //关闭蜂鸣器
   delay(250);       //延时     
}




/*****************************************************
函数功能：判断液晶模块的忙碌状态
返回值：result。result=1，忙碌;result=0，不忙
***************************************************/
 unsigned char BusyTest(void)
  {
    bit result;
	RS=0;       //根据规定，RS为低电平，RW为高电平时，可以读状态
    RW=1;
    E=1;        //E=1，才允许读写
    _nop_();   //空操作
    _nop_();
    _nop_(); 
    _nop_();   //空操作四个机器周期，给硬件反应时间	
    result=BF;  //将忙碌标志电平赋给result
	E=0;
    return result;
  }
/*****************************************************
函数功能：将模式设置指令或显示地址写入液晶模块
入口参数：dictate
***************************************************/
void WriteInstruction (unsigned char dictate)
{   
    while(BusyTest()==1); //如果忙就等待
	 RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
	 RW=0;   
	 E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
                             // 就是让E从0到1发生正跳变，所以应先置"0"
	 _nop_();
	 _nop_();             //空操作两个机器周期，给硬件反应时间
	 P0=dictate;            //将数据送入P0口，即写入指令或地址
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();               //空操作四个机器周期，给硬件反应时间
	 E=1;                   //E置高电平
	 _nop_();
	 _nop_();
	 _nop_();
	 _nop_();               //空操作四个机器周期，给硬件反应时间
	  E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
 }
/*****************************************************
函数功能：指定字符显示的实际地址
入口参数：x
***************************************************/
 void WriteAddress(unsigned char x)
 {
     WriteInstruction(x|0x80); //显示位置的确定方法规定为"80H+地址码x"
 }
/*****************************************************
函数功能：将数据(字符的标准ASCII码)写入液晶模块
入口参数：y(为字符常量)
***************************************************/
 void WriteData(unsigned char y)
 {
    while(BusyTest()==1);  
	  RS=1;           //RS为高电平，RW为低电平时，可以写入数据
	  RW=0;
	  E=0;            //E置低电平(根据表8-6，写指令时，E为高脉冲，
                       // 就是让E从0到1发生正跳变，所以应先置"0"
	  P0=y;           //将数据送入P0口，即将数据写入液晶模块
	  _nop_();
	  _nop_();
 	  _nop_();
     _nop_();       //空操作四个机器周期，给硬件反应时间
	  E=1;          //E置高电平
	  _nop_();
	  _nop_();
	  _nop_();
	 _nop_();        //空操作四个机器周期，给硬件反应时间
	 E=0;            //当E由高电平跳变成低电平时，液晶模块开始执行命令
 }
/*****************************************************
函数功能：对LCD的显示模式进行初始化设置
***************************************************/
void LcdInitiate(void)
{
   delay(15);             //延时15ms，首次写指令时应给LCD一段较长的反应时间
   WriteInstruction(0x38);  //显示模式设置：16×2显示，5×7点阵，8位数据接口
	delay(5);   //延时5ms　
	WriteInstruction(0x38);
	delay(5);
	WriteInstruction(0x38);
	delay(5);
	WriteInstruction(0x0C);  //显示模式设置：显示开，有光标，光标闪烁
	delay(5);
	WriteInstruction(0x06);  //显示模式设置：光标右移，字符不移
	delay(5);
	WriteInstruction(0x01);  //清屏幕指令，将以前的显示内容清除
	delay(5);
 }
/************************************************************
函数功能：对4个字节的用户码和键数据码进行解码
说明：解码正确，返回1，否则返回0
出口参数：dat
*************************************************************/
bit DeCode(void)        
{
    
   unsigned char  i,j;
	unsigned char temp;    //储存解码出的数据
	for(i=0;i<4;i++)      //连续读取4个用户码和键数据码
	  {
		 for(j=0;j<8;j++)  //每个码有8位数字
			 {
	         temp=temp>>1;  //temp中的各数据位右移一位，因为先读出的是高位数据									
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
		      while(IR==0)   //如果是低电平就等待
	               ;	      //低电平计时
		  	   TR0=0;         //关闭定时器T0
			   LowTime=TH0*256+TL0;    //保存低电平宽度
			   TH0=0;         //定时器清0
			   TL0=0;         //定时器清0
			   TR0=1;         //开启定时器T0
			   while(IR==1)   //如果是高电平就等待
			       ;			   
			   TR0=0;        //关闭定时器T0
			   HighTime=TH0*256+TL0;   //保存高电平宽度
			   if((LowTime<370)||(LowTime>640))
			  		    return 0;        //如果低电平长度不在合理范围，则认为出错，停止解码			
			   if((HighTime>420)&&(HighTime<620))   //如果高电平时间在560微秒左右，即计数560／1.085＝516次
			           temp=temp&0x7f;       //(520-100=420, 520+100=620)，则该位是0
			   if((HighTime>1300)&&(HighTime<1800)) //如果高电平时间在1680微秒左右，即计数1680／1.085＝1548次
			           temp=temp|0x80;       //(1550-250=1300,1550+250=1800),则该位是1
		     }  			            
	   a[i]=temp;	//将解码出的字节值储存在a[i]																					 
    }  				 		 
  if(a[2]=~a[3])  //验证键数据码和其反码是否相等,一般情况下不必验证用户码
	 return 1;     //解码正确，返回1
}

/*------------------二进制码转换为压缩型BCD码,并显示---------------*/

void two_2_bcd(unsigned char date)
{

   unsigned char temp;
   temp=date;
   date&=0xf0;
   date>>=4;                    //右移四位得到高四位码
   date&=0x0f;                  //与0x0f想与确保高四位为0
   if(date<=0x09)
   {                 
     WriteData(0x30+date);            //lcd显示键值高四位
   }
   else
   {
     date=date-0x09;
	 WriteData(0x40+date);
   }
   date=temp;
   date&=0x0f;
   if(date<=0x09)
   {
     WriteData(0x30+date);            //lcd显示低四位值
   }
   else
   {
     date=date-0x09;
	 WriteData(0x40+date);
   }
   WriteData(0x48);                 //显示字符'H'
} 
/************************************************************
函数功能：1602LCD显示
*************************************************************/
void Disp(void)
{  
    WriteAddress(0x40);  // 设置显示位置为第一行的第1个字
      two_2_bcd(a[0]);
	  WriteData(0x20);
	  two_2_bcd(a[1]);
	  	WriteData(0x20);
	  two_2_bcd(a[2]);
	  	 WriteData(0x20);
	  two_2_bcd(a[3]);
  
}
/************************************************************
函数功能：主函数
*************************************************************/
void main()
{
  	 unsigned char i;	
	LcdInitiate();         //调用LCD初始化函数  
    delay(10);
   		WriteInstruction(0x01);//清显示：清屏幕指令
		WriteAddress(0x00);  // 设置显示位置为第一行的第1个字
	  	i = 0;
		while(string[i] != '\0')    //'\0'是数组结束标志 
			{						// 显示字符	WWW.RICHMCU.COM
				WriteData(string[i]);
				i++;	
			}
	EA=1;        //开启总中断
   EX0=1;       //开外中断0
   ET0=1;       //定时器T0中断允许
   IT0=1;       //外中断的下降沿触发  
	TMOD=0x01;   //使用定时器T0的模式1	
	TR0=0;       //定时器T0关闭
   while(1);   //等待红外信号产生的中断
 	 
}
/************************************************************
函数功能：红外线触发的外中断处理函数
*************************************************************/
void Int0(void) interrupt 0
  {
     EX0=0;      //关闭外中断0，不再接收二次红外信号的中断，只解码当前红外信号
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0	 
	  while(IR==0);          //如果是低电平就等待，给引导码低电平计时
	  TR0=0;                //关闭定时器T0     
	  LowTime=TH0*256+TL0;  //保存低电平时间
	  TH0=0;      //定时器T0的高8位清0
	  TL0=0;      //定时器T0的低8位清0
	  TR0=1;	    //开启定时器T0
	  while(IR==1);  //如果是高电平就等待，给引导码高电平计时
	  TR0=0;        //关闭定时器T0
	  HighTime=TH0*256+TL0;	//保存引导码的高电平长度
     if((LowTime>7800)&&(LowTime<8800)&&(HighTime>3600)&&(HighTime<4700))
		 {
		    //如果是引导码,就开始解码,否则放弃,引导码的低电平计时
	       //次数＝9000us/1.085=8294, 判断区间:8300－500＝7800，8300＋500＝8800.
	      if(DeCode()==1) // 执行遥控解码功能
		 {
		
		  Disp();//调用1602LCD显示函数
		  beep();//蜂鸣器响一声 提示解码成功
		 }
		 }
	  EX0=1;   //开启外中断EX0
  }
