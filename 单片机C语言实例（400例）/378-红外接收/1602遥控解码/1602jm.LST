C51 COMPILER V8.02   1602JM                                                                07/21/2009 18:33:17 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE 1602JM
OBJECT MODULE PLACED IN 1602jm.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE 1602jm.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include <at89x52.h>
   2          #define uchar unsigned char
   3          #define uint  unsigned int 
   4          
   5          /*----------------------------控制I/O口设置，根据实际而定---------------*/
   6          #define  RS    P2_0        //RS数据命令选择端，高电平数据，低电平命令
   7          #define  RW    P2_1        //RW读写选择端，高电平读操作，低电平写操作
   8          #define   E    P2_2        //E使能控制端，E高电平跳变为低电平时LCD执行命令
   9          #define   DATA P0          //数据端口定义
  10          #define   D0   P0_0
  11          #define   D1   P0_1
  12          #define   D2   P0_2
  13          #define   D3   P0_3
  14          #define   D4   P0_4
  15          #define   D5   P0_5
  16          #define   D6   P0_6
  17          #define   D7   P0_7
  18          #define   IR_RE P3_2
  19          /*------------------------------------------------------------------------------*/
  20            bit   k=0;                                      //红外解码判断标志位，为0则为有效信号，为1则为无效
  21            uchar n=0;                                      //用来控制外部中断
  22            uchar code str0[16]=" REMOTE CONTROL";          //开机画面显示
  23            uchar code str1[16]="  IR-CODE: ";
  24            uchar code str2[16]="ERROR";
  25            uchar *p0=str0;
  26            uchar *p1=str1;
  27            uchar *p2=str2;
  28            delay1ms(uint k); 
  29            void disp(void);                            //红外键值显示程序
  30            uchar  data date[4];                        //date数组为存放地址原码，反码，数据原码，反码 
  31            
  32          /*------------------------LCD忙判断子程序--------------------------------------*/
  33          
  34          void busy()
  35          {
  36   1        RS=0;RW=1;
  37   1        E=0;E=1;DATA=0xff;
  38   1        while(D7);
  39   1      }
  40          
  41          /*----------------------- 写命令子程序-----------------------------------------*/
  42          
  43          void wcom(uchar com)
  44          {
  45   1        busy();
  46   1        RS=0;RW=0;
  47   1        E=1;
  48   1        DATA=com;
  49   1        E=0;
  50   1      }
  51          
  52          /*-------------------------写数据子程序--------------------------------------*/
  53          
  54          void wdata(uchar dat)
  55          {
C51 COMPILER V8.02   1602JM                                                                07/21/2009 18:33:17 PAGE 2   

  56   1        busy();
  57   1        RS=1;RW=0;
  58   1        E=1;
  59   1        DATA=dat;
  60   1        E=0;
  61   1      }
  62          /*--------------------------延时1ms程子程序-----------------------*/
  63          delay1000()             
  64          {
  65   1         uint i,j;
  66   1         for(i=0;i<1;i++)
  67   1           for(j=0;j<124;j++)
  68   1           ;
  69   1      }
  70          
  71          /*---------------------------延时882us子程序-----------------------*/
  72          
  73          delay882()
  74          {
  75   1         uint i,j;
  76   1         for(i=0;i<1;i++)                  
  77   1           for(j=0;j<109;j++)
  78   1           ;
  79   1      }
  80          
  81          /*--------------------------延时2400ms程子程序-----------------------*/
  82          
  83          delay2400()                                          
  84          {
  85   1         uint i,j;
  86   1         for(i=0;i<3;i++)          
  87   1           for(j=0;j<99;j++)
  88   1            ;
  89   1      }
  90          
  91          
  92          /*--------------------------以下为初始化程序，由上面子程序组成，根据个人爱好-----------*/
  93          
  94          
  95          /******************************清屏程序***********************************/
  96           void clear()
  97           { wcom (0x01);}
  98          
  99          /*******************8*****888**88888显示模式设定8888888888888888888888*/
 100          
 101          void  mode(bit x)
 102           {
 103   1          if(x==1)wcom(0x38);          //两行5*8 mode 
 104   1              else wcom(0x34);            //一行5*10 mode
 105   1       }
 106          /*------------------------显示开关控制命令----------------------------*/
 107          
 108          void on_off(bit x)
 109          {
 110   1        if(x==1)wcom(0x0f);           //显示开，光标开，光标闪烁
 111   1        else wcom(0x0c);             //显示开，光标关
 112   1      }
 113          
 114          
 115          /*------------------------init初始化组合-------------------------*/
 116          
 117          void init()
C51 COMPILER V8.02   1602JM                                                                07/21/2009 18:33:17 PAGE 3   

 118          {
 119   1        clear();          //清屏
 120   1        mode(1);          //模式设置
 121   1        on_off(1);         //显示设置
 122   1        wcom(0x06);        //移动方式
 123   1      }
 124          
 125          /*---------------------------对字符串的处理------------------------*/
 126          
 127          void strchar(uchar *p)
 128          {
 129   1        while(*p!='\0')
 130   1        {
 131   2          wdata(*p);
 132   2              p++;
 133   2        }
 134   1      }
 135          
 136          /*----------------------------------------------------------*/
 137          /*-----------------------红外解码程序(核心)-----------------*/
 138          /*----------------------------------------------------------*/
 139          
 140          void IR_decode()
 141          {
 142   1        uchar  i,j;
 143   1        while(IR_RE==0);
 144   1        delay2400();
 145   1        if(IR_RE==1)                               //延时2.4ms后如果是高电平则是新码
 146   1        {
 147   2           delay2400();                            //延时4.8ms避开4.5ms的高电平
 148   2               for(i=0;i<4;i++)
 149   2               {
 150   3                 for(j=0;j<8;j++)
 151   3                 {
 152   4                 while(IR_RE==0);                       //等待地址码第1位高电平到来
 153   4                 delay882();                         //延时882ms判断此时引脚电平
 154   4                 if(IR_RE==0)
 155   4                 {       
 156   5                                date[i]>>=1;
 157   5                                date[i]=date[i]&0x7f;                   
 158   5                 }
 159   4                 else if(IR_RE==1)
 160   4                         {
 161   5                                delay1000();
 162   5                                date[i]>>=1;
 163   5                                date[i]=date[i]|0x80;
 164   5                         }
 165   4                      }                                    //1位数据接收结束
 166   3           }                                       //32位二进制码接收结束
 167   2         } 
 168   1      }
 169          
 170          
 171          
 172          /*------------------二进制码转换为压缩型BCD码,并显示---------------*/
 173          
 174          void two_2_bcd(uchar date)
 175          {
 176   1      
 177   1         uchar temp;
 178   1         temp=date;
 179   1         date&=0xf0;
C51 COMPILER V8.02   1602JM                                                                07/21/2009 18:33:17 PAGE 4   

 180   1         date>>=4;                    //右移四位得到高四位码
 181   1         date&=0x0f;                  //与0x0f想与确保高四位为0
 182   1         if(date<=0x09)
 183   1         {                  
 184   2           wdata(0x30+date);            //lcd显示键值高四位
 185   2         }
 186   1         else
 187   1         {
 188   2           date=date-0x09;
 189   2               wdata(0x40+date);
 190   2         }
 191   1         date=temp;
 192   1         date&=0x0f;
 193   1         if(date<=0x09)
 194   1         {
 195   2           wdata(0x30+date);            //lcd显示低四位值
 196   2         }
 197   1         else
 198   1         {
 199   2           date=date-0x09;
 200   2               wdata(0x40+date);
 201   2         }
 202   1         wdata(0x48);                 //显示字符'H'
 203   1      } 
 204          
 205          
 206          //////////////////////////////转换程序结束///////////////////////////
 207          
 208          
 209          /*----------------------解码成功后,1602显示键值子程序---------------*/
 210          
 211          void disp()
 212          {
 213   1         uchar date1;
 214   1         date1=date[3]^0xff;               //如果得到的数据原码和数据反码相反
 215   1         if(date[2]==date1)                 //显示键值
 216   1         {  
 217   2         wcom(0xc0);
 218   2            two_2_bcd(date[0]);
 219   2                wdata(0x20);
 220   2                two_2_bcd(date[1]);
 221   2                        wdata(0x20);
 222   2                two_2_bcd(date[2]);
 223   2                        wdata(0x20);
 224   2                two_2_bcd(date[3]);
 225   2         }
 226   1      }
 227          
 228          
 229          /*------------------------外部中断0程序-------------------------*/
 230          /*------------------主要用于处理红外遥控键值--------------------*/
 231          
 232          void int0() interrupt 0
 233          { 
 234   1         uint i;
 235   1         for(i=0;i<4;i++)
 236   1         { 
 237   2           delay1000();
 238   2               if(IR_RE==1){k=~k;}                   //刚开始为4.5ms的引导码，如果4ms内出现高电平则退出解码程序
 239   2         }
 240   1      
 241   1         if(k==0)
C51 COMPILER V8.02   1602JM                                                                07/21/2009 18:33:17 PAGE 5   

 242   1         { 
 243   2         EX0=0;                                //检测到有效信号关中断，防止干扰
 244   2         IR_decode();                          //如果接收到的是有效信号，则调用解码程序
 245   2         disp();                               //解码成功，调用显示程序，显示该键值
 246   2         }
 247   1        EX0=1;                                 //开外部中断，允许新的遥控按键
 248   1      }
 249          
 250          
 251          
 252          /*---------------------------------------------------------------*/
 253          /*           以下为主程序，主要对LCD初始化，开始界面设置         */
 254          /*---------------------------------------------------------------*/
 255          void main(void)
 256          {
 257   1      
 258   1        TMOD=0x11;                              //定时器模式设置所选为 模式1
 259   1        TH0=0xd8;                               //定时器初值理论为 10ms;
 260   1        TL0=0xf7;                               //实际取d8f7
 261   1        ET0=1;                                  //允许定时器0中断
 262   1        EX0=1;                                  //允许外部中断0,用于检测红外遥控器按键
 263   1        EA=1;                                   //总中断开
 264   1        init();                                 //初始化LCD
 265   1        wcom(0x80);                             //写入字符的地址为第1行第1列
 266   1        strchar(p0);                            //调用显示字符串函数
 267   1        wcom(0xc0);
 268   1        while(1);
 269   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    515    ----
   CONSTANT SIZE    =     48    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     14       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1       2
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
