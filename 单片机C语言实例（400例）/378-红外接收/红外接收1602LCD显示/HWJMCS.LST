C51 COMPILER V8.02   HWJMCS                                                                07/22/2009 14:26:22 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE HWJMCS
OBJECT MODULE PLACED IN HWJMCS.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE HWJMCS.C BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //本解码程序适用于NEC的upd6121及其兼容芯片的解码，支持大多数遥控器 实验板采用11.0592MHZ晶振
   2          #include<reg52.h>       //包含单片机寄存器的头文件
   3          #include<intrins.h>  //包含_nop_()函数定义的头文件
   4          sbit IR=P3^2;           //将IR位定义为P3.2引脚
   5          sbit RS=P2^0;    //寄存器选择位，将RS位定义为P2.0引脚
   6          sbit RW=P2^1;    //读写选择位，将RW位定义为P2.1引脚
   7          sbit E=P2^2;     //使能信号位，将E位定义为P2.2引脚
   8          sbit BF=P0^7;    //忙碌标志位，，将BF位定义为P0.7引脚
   9          sbit BEEP = P3^6; //蜂鸣器控制端口P36 
  10          unsigned char flag;
  11          unsigned char code string[ ]= {"1602IR-CODE TEST"}; 
  12          unsigned char a[4];    //储存用户码、用户反码与键数据码、键数据反码
  13          unsigned int LowTime,HighTime; //储存高、低电平的宽度 
  14          /*****************************************************
  15          函数功能：延时1ms
  16          ***************************************************/
  17          void delay1ms()
  18          {
  19   1         unsigned char i,j;   
  20   1               for(i=0;i<10;i++)
  21   1                for(j=0;j<33;j++)
  22   1                 ;             
  23   1       }
  24           /*****************************************************
  25          函数功能：延时若干毫秒
  26          入口参数：n
  27          ***************************************************/
  28           void delay(unsigned char n)
  29           {
  30   1         unsigned char i;
  31   1              for(i=0;i<n;i++)
  32   1                 delay1ms();
  33   1       }
  34          
  35          
  36          
  37          /*********************************************************/
  38          void beep()             //蜂鸣器响一声函数
  39          {
  40   1        unsigned char i;
  41   1        for (i=0;i<100;i++)
  42   1         {
  43   2         delay1ms();
  44   2         BEEP=!BEEP;       //BEEP取反
  45   2         } 
  46   1         BEEP=1;           //关闭蜂鸣器
  47   1         delay(250);       //延时     
  48   1      }
  49          
  50          
  51          
  52          
  53          /*****************************************************
  54          函数功能：判断液晶模块的忙碌状态
  55          返回值：result。result=1，忙碌;result=0，不忙
C51 COMPILER V8.02   HWJMCS                                                                07/22/2009 14:26:22 PAGE 2   

  56          ***************************************************/
  57           unsigned char BusyTest(void)
  58            {
  59   1          bit result;
  60   1              RS=0;       //根据规定，RS为低电平，RW为高电平时，可以读状态
  61   1          RW=1;
  62   1          E=1;        //E=1，才允许读写
  63   1          _nop_();   //空操作
  64   1          _nop_();
  65   1          _nop_(); 
  66   1          _nop_();   //空操作四个机器周期，给硬件反应时间     
  67   1          result=BF;  //将忙碌标志电平赋给result
  68   1              E=0;
  69   1          return result;
  70   1        }
  71          /*****************************************************
  72          函数功能：将模式设置指令或显示地址写入液晶模块
  73          入口参数：dictate
  74          ***************************************************/
  75          void WriteInstruction (unsigned char dictate)
  76          {   
  77   1          while(BusyTest()==1); //如果忙就等待
  78   1               RS=0;                  //根据规定，RS和R/W同时为低电平时，可以写入指令
  79   1               RW=0;   
  80   1               E=0;                   //E置低电平(根据表8-6，写指令时，E为高脉冲，
  81   1                                   // 就是让E从0到1发生正跳变，所以应先置"0"
  82   1               _nop_();
  83   1               _nop_();             //空操作两个机器周期，给硬件反应时间
  84   1               P0=dictate;            //将数据送入P0口，即写入指令或地址
  85   1               _nop_();
  86   1               _nop_();
  87   1               _nop_();
  88   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  89   1               E=1;                   //E置高电平
  90   1               _nop_();
  91   1               _nop_();
  92   1               _nop_();
  93   1               _nop_();               //空操作四个机器周期，给硬件反应时间
  94   1                E=0;                  //当E由高电平跳变成低电平时，液晶模块开始执行命令
  95   1       }
  96          /*****************************************************
  97          函数功能：指定字符显示的实际地址
  98          入口参数：x
  99          ***************************************************/
 100           void WriteAddress(unsigned char x)
 101           {
 102   1           WriteInstruction(x|0x80); //显示位置的确定方法规定为"80H+地址码x"
 103   1       }
 104          /*****************************************************
 105          函数功能：将数据(字符的标准ASCII码)写入液晶模块
 106          入口参数：y(为字符常量)
 107          ***************************************************/
 108           void WriteData(unsigned char y)
 109           {
 110   1          while(BusyTest()==1);  
 111   1                RS=1;           //RS为高电平，RW为低电平时，可以写入数据
 112   1                RW=0;
 113   1                E=0;            //E置低电平(根据表8-6，写指令时，E为高脉冲，
 114   1                             // 就是让E从0到1发生正跳变，所以应先置"0"
 115   1                P0=y;           //将数据送入P0口，即将数据写入液晶模块
 116   1                _nop_();
 117   1                _nop_();
C51 COMPILER V8.02   HWJMCS                                                                07/22/2009 14:26:22 PAGE 3   

 118   1                _nop_();
 119   1           _nop_();       //空操作四个机器周期，给硬件反应时间
 120   1                E=1;          //E置高电平
 121   1                _nop_();
 122   1                _nop_();
 123   1                _nop_();
 124   1               _nop_();        //空操作四个机器周期，给硬件反应时间
 125   1               E=0;            //当E由高电平跳变成低电平时，液晶模块开始执行命令
 126   1       }
 127          /*****************************************************
 128          函数功能：对LCD的显示模式进行初始化设置
 129          ***************************************************/
 130          void LcdInitiate(void)
 131          {
 132   1         delay(15);             //延时15ms，首次写指令时应给LCD一段较长的反应时间
 133   1         WriteInstruction(0x38);  //显示模式设置：16×2显示，5×7点阵，8位数据接口
 134   1              delay(5);   //延时5ms　
 135   1              WriteInstruction(0x38);
 136   1              delay(5);
 137   1              WriteInstruction(0x38);
 138   1              delay(5);
 139   1              WriteInstruction(0x0C);  //显示模式设置：显示开，有光标，光标闪烁
 140   1              delay(5);
 141   1              WriteInstruction(0x06);  //显示模式设置：光标右移，字符不移
 142   1              delay(5);
 143   1              WriteInstruction(0x01);  //清屏幕指令，将以前的显示内容清除
 144   1              delay(5);
 145   1       }
 146          /************************************************************
 147          函数功能：对4个字节的用户码和键数据码进行解码
 148          说明：解码正确，返回1，否则返回0
 149          出口参数：dat
 150          *************************************************************/
 151          bit DeCode(void)        
 152          {
 153   1          
 154   1         unsigned char  i,j;
 155   1              unsigned char temp;    //储存解码出的数据
 156   1              for(i=0;i<4;i++)      //连续读取4个用户码和键数据码
 157   1                {
 158   2                       for(j=0;j<8;j++)  //每个码有8位数字
 159   2                               {
 160   3                       temp=temp>>1;  //temp中的各数据位右移一位，因为先读出的是高位数据                                                                      
 161   3                                 TH0=0;         //定时器清0
 162   3                                 TL0=0;         //定时器清0
 163   3                                 TR0=1;         //开启定时器T0
 164   3                            while(IR==0)   //如果是低电平就等待
 165   3                             ;              //低电平计时
 166   3                                 TR0=0;         //关闭定时器T0
 167   3                                 LowTime=TH0*256+TL0;    //保存低电平宽度
 168   3                                 TH0=0;         //定时器清0
 169   3                                 TL0=0;         //定时器清0
 170   3                                 TR0=1;         //开启定时器T0
 171   3                                 while(IR==1)   //如果是高电平就等待
 172   3                                     ;                           
 173   3                                 TR0=0;        //关闭定时器T0
 174   3                                 HighTime=TH0*256+TL0;   //保存高电平宽度
 175   3                                 if((LowTime<370)||(LowTime>640))
 176   3                                                  return 0;        //如果低电平长度不在合理范围，则认为出错，停止解码                 
 177   3                                 if((HighTime>420)&&(HighTime<620))   //如果高电平时间在560微秒左右，即计数560／1.085＝516次
 178   3                                         temp=temp&0x7f;       //(520-100=420, 520+100=620)，则该位是0
 179   3                                 if((HighTime>1300)&&(HighTime<1800)) //如果高电平时间在1680微秒左右，即计数1680／1.085＝1548次
C51 COMPILER V8.02   HWJMCS                                                                07/22/2009 14:26:22 PAGE 4   

 180   3                                         temp=temp|0x80;       //(1550-250=1300,1550+250=1800),则该位是1
 181   3                           }                                      
 182   2                 a[i]=temp;   //将解码出的字节值储存在a[i]                                                                                                                                                                     
 183   2          }                                            
 184   1        if(a[2]=~a[3])  //验证键数据码和其反码是否相等,一般情况下不必验证用户码
 185   1               return 1;     //解码正确，返回1
 186   1      }
 187          
 188          /*------------------二进制码转换为压缩型BCD码,并显示---------------*/
 189          
 190          void two_2_bcd(unsigned char date)
 191          {
 192   1      
 193   1         unsigned char temp;
 194   1         temp=date;
 195   1         date&=0xf0;
 196   1         date>>=4;                    //右移四位得到高四位码
 197   1         date&=0x0f;                  //与0x0f想与确保高四位为0
 198   1         if(date<=0x09)
 199   1         {                 
 200   2           WriteData(0x30+date);            //lcd显示键值高四位
 201   2         }
 202   1         else
 203   1         {
 204   2           date=date-0x09;
 205   2               WriteData(0x40+date);
 206   2         }
 207   1         date=temp;
 208   1         date&=0x0f;
 209   1         if(date<=0x09)
 210   1         {
 211   2           WriteData(0x30+date);            //lcd显示低四位值
 212   2         }
 213   1         else
 214   1         {
 215   2           date=date-0x09;
 216   2               WriteData(0x40+date);
 217   2         }
 218   1         WriteData(0x48);                 //显示字符'H'
 219   1      } 
 220          /************************************************************
 221          函数功能：1602LCD显示
 222          *************************************************************/
 223          void Disp(void)
 224          {  
 225   1          WriteAddress(0x40);  // 设置显示位置为第一行的第1个字
 226   1            two_2_bcd(a[0]);
 227   1                WriteData(0x20);
 228   1                two_2_bcd(a[1]);
 229   1                      WriteData(0x20);
 230   1                two_2_bcd(a[2]);
 231   1                       WriteData(0x20);
 232   1                two_2_bcd(a[3]);
 233   1        
 234   1      }
 235          /************************************************************
 236          函数功能：主函数
 237          *************************************************************/
 238          void main()
 239          {
 240   1               unsigned char i;       
 241   1              LcdInitiate();         //调用LCD初始化函数  
C51 COMPILER V8.02   HWJMCS                                                                07/22/2009 14:26:22 PAGE 5   

 242   1          delay(10);
 243   1                      WriteInstruction(0x01);//清显示：清屏幕指令
 244   1                      WriteAddress(0x00);  // 设置显示位置为第一行的第1个字
 245   1                      i = 0;
 246   1                      while(string[i] != '\0')    //'\0'是数组结束标志 
 247   1                              {                                               // 显示字符     WWW.RICHMCU.COM
 248   2                                      WriteData(string[i]);
 249   2                                      i++;    
 250   2                              }
 251   1              EA=1;        //开启总中断
 252   1         EX0=1;       //开外中断0
 253   1         ET0=1;       //定时器T0中断允许
 254   1         IT0=1;       //外中断的下降沿触发  
 255   1              TMOD=0x01;   //使用定时器T0的模式1      
 256   1              TR0=0;       //定时器T0关闭
 257   1         while(1);   //等待红外信号产生的中断
 258   1               
 259   1      }
 260          /************************************************************
 261          函数功能：红外线触发的外中断处理函数
 262          *************************************************************/
 263          void Int0(void) interrupt 0
 264            {
 265   1           EX0=0;      //关闭外中断0，不再接收二次红外信号的中断，只解码当前红外信号
 266   1                TH0=0;      //定时器T0的高8位清0
 267   1                TL0=0;      //定时器T0的低8位清0
 268   1                TR0=1;            //开启定时器T0       
 269   1                while(IR==0);          //如果是低电平就等待，给引导码低电平计时
 270   1                TR0=0;                //关闭定时器T0     
 271   1                LowTime=TH0*256+TL0;  //保存低电平时间
 272   1                TH0=0;      //定时器T0的高8位清0
 273   1                TL0=0;      //定时器T0的低8位清0
 274   1                TR0=1;            //开启定时器T0
 275   1                while(IR==1);  //如果是高电平就等待，给引导码高电平计时
 276   1                TR0=0;        //关闭定时器T0
 277   1                HighTime=TH0*256+TL0; //保存引导码的高电平长度
 278   1           if((LowTime>7800)&&(LowTime<8800)&&(HighTime>3600)&&(HighTime<4700))
 279   1                       {
 280   2                          //如果是引导码,就开始解码,否则放弃,引导码的低电平计时
 281   2                     //次数＝9000us/1.085=8294, 判断区间:8300－500＝7800，8300＋500＝8800.
 282   2                    if(DeCode()==1) // 执行遥控解码功能
 283   2                       {
 284   3                      
 285   3                        Disp();//调用1602LCD显示函数
 286   3                        beep();//蜂鸣器响一声 提示解码成功
 287   3                       }
 288   2                       }
 289   1                EX0=1;   //开启外中断EX0
 290   1        }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    676    ----
   CONSTANT SIZE    =     17    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      9    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
