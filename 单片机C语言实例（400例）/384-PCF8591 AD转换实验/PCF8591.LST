C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 1   


C51 COMPILER V8.02, COMPILATION OF MODULE PCF8591
OBJECT MODULE PLACED IN PCF8591.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE PCF8591.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          
   2          //-----------------------函数声明，变量定义------------------------
   3          #include <reg51.h>
   4          #include <intrins.h>
   5          sbit SCL=P3^4;                   // 将p1.2口模拟时钟口
   6          sbit SDA=P3^5;                   // 将p1.3口模拟数据口
   7          bit askflag;
   8          #define uchar unsigned char
   9          #define uint  unsigned int
  10          #define disdata  P0              //显示数据码输出口
  11          
  12          sbit LCD_RS = P2^0;             
  13          sbit LCD_RW = P2^1;
  14          sbit LCD_EN = P2^2;
  15          
  16          uint data dis[4]={0x00,0x00,0x00,0x00}; 
  17                                    //定义3个显示数据单元和1个数据存储单元
  18          
  19          uchar code dis4[] = {"1- .  V  2- .  V"};
  20          uchar code dis5[] = {"3- .  V  4- .  V"};
  21          
  22          
  23          #define delayNOP(); {_nop_();_nop_();_nop_();_nop_();};
  24                                   
  25          bit   bdata SystemError;                //从机错误标志位
  26          
  27          /*********************** PCF8591专用变量定义 ***********************/
  28          
  29          #define PCF8591_WRITE   0x90 
  30          #define PCF8591_READ    0x91
  31          #define  NUM  4                     //接收和发送缓存区的深度
  32          uchar idata receivebuf[NUM];    //数据接收缓冲区
  33          
  34          /*******************************************************************/
  35          /*                                                                 */
  36          /*  延时函数                                                       */
  37          /*                                                                 */
  38          /*******************************************************************/
  39          
  40          void delay(int ms)
  41          {
  42   1          while(ms--)
  43   1              {
  44   2            uchar i;
  45   2                for(i=0;i<250;i++)  
  46   2                 {
  47   3                  _nop_();                       
  48   3                      _nop_();
  49   3                      _nop_();
  50   3                      _nop_();
  51   3                 }
  52   2              }
  53   1      }               
  54          
  55          /*******************************************************************/
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 2   

  56          /*                                                                 */
  57          /*检查LCD忙状态                                                    */
  58          /*lcd_busy为1时，忙，等待。lcd-busy为0时,闲，可写指令与数据。      */
  59          /*                                                                 */
  60          /*******************************************************************/ 
  61          
  62          bit lcd_busy()
  63           {                          
  64   1          bit result;
  65   1          LCD_RS = 0;
  66   1          LCD_RW = 1;
  67   1          LCD_EN = 1;
  68   1          delayNOP();
  69   1          result = (bit)(P0&0x80);
  70   1          LCD_EN = 0;
  71   1          return(result); 
  72   1       }
  73          
  74          /*******************************************************************/
  75          /*                                                                 */
  76          /*写指令数据到LCD                                                  */
  77          /*RS=L，RW=L，E=高脉冲，D0-D7=指令码。                             */
  78          /*                                                                 */
  79          /*******************************************************************/
  80          
  81          void lcd_wcmd(uchar cmd)
  82          
  83          {                          
  84   1         while(lcd_busy());
  85   1          LCD_RS = 0;
  86   1          LCD_RW = 0;
  87   1          LCD_EN = 0;
  88   1          _nop_();
  89   1          _nop_(); 
  90   1          P0 = cmd;
  91   1          delayNOP();
  92   1          LCD_EN = 1;
  93   1          delayNOP();
  94   1          LCD_EN = 0;  
  95   1      }
  96          
  97          /*******************************************************************/
  98          /*                                                                 */
  99          /*写显示数据到LCD                                                  */
 100          /*RS=H，RW=L，E=高脉冲，D0-D7=数据。                               */
 101          /*                                                                 */
 102          /*******************************************************************/
 103          
 104          void lcd_wdat(uchar dat)
 105          {                          
 106   1         while(lcd_busy());
 107   1          LCD_RS = 1;
 108   1          LCD_RW = 0;
 109   1          LCD_EN = 0;
 110   1          P0 = dat;
 111   1          delayNOP();
 112   1          LCD_EN = 1;
 113   1          delayNOP();
 114   1          LCD_EN = 0; 
 115   1      }
 116          
 117          /*******************************************************************/
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 3   

 118          /*                                                                 */
 119          /*  LCD初始化设定                                                  */
 120          /*                                                                 */
 121          /*******************************************************************/
 122          
 123          void lcd_init()
 124          { 
 125   1          delay(15);                   
 126   1          lcd_wcmd(0x38);      //16*2显示，5*7点阵，8位数据
 127   1          delay(5);
 128   1          lcd_wcmd(0x38);         
 129   1          delay(5);
 130   1          lcd_wcmd(0x38);         
 131   1          delay(5);
 132   1      
 133   1          lcd_wcmd(0x0c);      //显示开，关光标
 134   1          delay(5);
 135   1          lcd_wcmd(0x06);      //移动光标
 136   1          delay(5);
 137   1          lcd_wcmd(0x01);      //清除LCD的显示内容
 138   1          delay(5);
 139   1      }
 140          
 141          /*******************************************************************/
 142          /*                                                                 */
 143          /*  设定显示位置                                                   */
 144          /*                                                                 */
 145          /*******************************************************************/
 146          
 147          void lcd_pos(uchar pos)
 148          {                          
 149   1        lcd_wcmd(pos | 0x80);  //数据指针=80+地址变量
 150   1      }
 151          
 152          /******************************************************************/
 153          /*                                                                */
 154          /* 数据处理与显示                                                 */
 155          /* 将采集到的数据进行16进制转换为ASCLL码。                        */
 156          /*                                                                */
 157          /******************************************************************/
 158          
 159          show_value(uchar ad_data)
 160          
 161          {   
 162   1          dis[2]=ad_data/51;   //AD值转换为3为BCD码，最大为5.00V。
 163   1          dis[2]=dis[2]+0x30;  //转换为ACSII码
 164   1          dis[3]=ad_data%51;   //余数暂存
 165   1          dis[3]=dis[3]*10;    //计算小数第一位
 166   1          dis[1]=dis[3]/51;
 167   1          dis[1]=dis[1]+0x30;  //转换为ACSII码
 168   1          dis[3]=dis[3]%51;
 169   1          dis[3]=dis[3]*10;    //计算小数第二位
 170   1          dis[0]=dis[3]/51;                                                                             //
 171   1          dis[0]=dis[0]+0x30;  //转换为ACSII码           
 172   1      } 
 173          //-------------------------------------------------------------------
 174          // 函数名称： iic_start()
 175          // 函数功能： 启动I2C总线子程序
 176          //-------------------------------------------------------------------
 177          void iic_start(void)
 178          { //时钟保持高，数据线从高到低一次跳变，I2C通信开始
 179   1              SDA = 1;     
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 4   

 180   1              SCL = 1;
 181   1              delayNOP();      // 延时5us 
 182   1              SDA = 0;
 183   1              delayNOP();
 184   1          SCL = 0;
 185   1      }
 186          //-------------------------------------------------------------------
 187          // 函数名称： iic_stop()
 188          // 函数功能： 停止I2C总线数据传送子程序
 189          //-------------------------------------------------------------------
 190          void iic_stop(void)
 191          {       
 192   1              SDA = 0;           //时钟保持高，数据线从低到高一次跳变，I2C通信停止
 193   1              SCL = 1;
 194   1              delayNOP();
 195   1              SDA = 1;
 196   1              delayNOP();
 197   1          SCL = 0;
 198   1      }
 199          //------------------------------------------------------------------
 200          // 函数名称： iicInit_()
 201          // 函数功能： 初始化I2C总线子程序
 202          //------------------------------------------------------------------
 203           void iicInit(void)
 204             {
 205   1         SCL = 0;
 206   1         iic_stop();  
 207   1         }  
 208          //-------------------------------------------------------------------
 209          // 函数名称： slave_ACK
 210          // 函数功能： 从机发送应答位子程序
 211          //-------------------------------------------------------------------
 212          void slave_ACK(void)
 213          {
 214   1              SDA = 0;  
 215   1              SCL = 1;
 216   1              delayNOP();     
 217   1              SCL = 0;
 218   1      }
 219          //-------------------------------------------------------------------
 220          // 函数名称： slave_NOACK
 221          // 函数功能： 从机发送非应答位子程序，迫使数据传输过程结束
 222          //-------------------------------------------------------------------
 223          void slave_NOACK(void)
 224          { 
 225   1              SDA = 1;
 226   1              SCL = 1;
 227   1              delayNOP();
 228   1              SDA = 0;
 229   1          SCL = 0;  
 230   1      }
 231          //-------------------------------------------------------------------
 232          // 函数名称： check_ACK
 233          // 函数功能： 主机应答位检查子程序，迫使数据传输过程结束
 234          //-------------------------------------------------------------------
 235          void check_ACK(void)
 236          {           
 237   1          SDA = 1;        // 将p1.1设置成输入，必须先向端口写1
 238   1              SCL = 1;
 239   1              askflag = 0;
 240   1              delayNOP();   
 241   1              if(SDA == 1)    // 若SDA=1表明非应答，置位非应答标志askflag
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 5   

 242   1          askflag = 1;
 243   1              SCL = 0;
 244   1      }
 245          //-------------------------------------------------------------------
 246          // 函数名称： IICSendByte
 247          // 入口参数： ch
 248          // 函数功能： 发送一个字节
 249          //-------------------------------------------------------------------
 250          void IICSendByte(uchar ch)
 251           
 252          {
 253   1              unsigned char idata n=8;     // 向SDA上发送一位数据字节，共八位
 254   1      
 255   1              while(n--)
 256   1              { 
 257   2              if((ch&0x80) == 0x80)    // 若要发送的数据最高位为1则发送位1
 258   2                 {
 259   3                              SDA = 1;    // 传送位1
 260   3                              SCL = 1;
 261   3                          delayNOP();
 262   3                      //      SDA = 0;        
 263   3                              SCL = 0; 
 264   3                 }
 265   2                      else
 266   2                      {  
 267   3                              SDA = 0;    // 否则传送位0
 268   3                              SCL = 1;
 269   3                              delayNOP();
 270   3                              SCL = 0;
 271   3                      }
 272   2                      ch = ch<<1;    // 数据左移一位
 273   2              }
 274   1      }
 275          //-------------------------------------------------------------------
 276          // 函数名称： IICreceiveByte
 277          // 返回接收的数据
 278          // 函数功能： 接收一字节子程序
 279          //-------------------------------------------------------------------
 280          uchar IICreceiveByte(void)
 281          {
 282   1              uchar idata n=8;     // 从SDA线上读取一上数据字节，共八位
 283   1              uchar tdata=0;
 284   1              while(n--)
 285   1              {
 286   2                 SDA = 1;
 287   2                 SCL = 1;
 288   2                 tdata =tdata<<1;                 //左移一位
 289   2                      if(SDA == 1)
 290   2                        tdata = tdata|0x01;   // 若接收到的位为1，则数据的最后一位置1
 291   2                      else 
 292   2                        tdata = tdata&0xfe;   // 否则数据的最后一位置0
 293   2                 SCL = 0;
 294   2               }
 295   1      
 296   1               return(tdata);
 297   1      }
 298          //-------------------------------------------------------------------
 299          // 函数名称： DAC_PCF8591
 300          // 入口参数： slave_add从机地址,n要发送的数据个数
 301          // 函数功能： 发送n位数据子程序
 302          //-------------------------------------------------------------------
 303          void DAC_PCF8591(uchar controlbyte,uchar w_data)
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 6   

 304          {    
 305   1              
 306   1              iic_start();                    // 启动I2C
 307   1              delayNOP();
 308   1      
 309   1              IICSendByte(PCF8591_WRITE);     // 发送地址位
 310   1              check_ACK();                    // 检查应答位
 311   1          if(askflag == 1)
 312   1               { 
 313   2                      SystemError = 1;
 314   2                      return;                     // 若非应答，置错误标志位
 315   2           }
 316   1          IICSendByte(controlbyte&0x77);      //Control byte 
 317   1              check_ACK();                    //检查应答位
 318   1          if(askflag == 1)
 319   1               { 
 320   2                      SystemError = 1;
 321   2                      return;                    // 若非应答，置错误标志位
 322   2               }
 323   1          IICSendByte(w_data);               //data byte
 324   1              check_ACK();                  // 检查应答位
 325   1          if(askflag == 1)
 326   1               { 
 327   2                      SystemError = 1;
 328   2              return;   // 若非应答表明器件错误或已坏，置错误标志位SystemError
 329   2               }
 330   1              iic_stop();         // 全部发完则停止
 331   1              delayNOP();
 332   1              delayNOP();
 333   1              delayNOP();
 334   1              delayNOP();     
 335   1      }
 336          //-------------------------------------------------------------------
 337          // 函数名称： ADC_PCF8591
 338          // 入口参数： controlbyte控制字
 339          // 函数功能： 连续读入4路通道的A/D转换结果到receivebuf
 340          //-------------------------------------------------------------------
 341          void ADC_PCF8591(uchar controlbyte)
 342          { 
 343   1          uchar idata receive_da,i=0;
 344   1      
 345   1              iic_start();
 346   1      
 347   1              IICSendByte(PCF8591_WRITE);     //控制字
 348   1              check_ACK();
 349   1              if(askflag == 1)
 350   1              {
 351   2                      SystemError = 1;
 352   2                      return;
 353   2              }
 354   1      
 355   1              IICSendByte(controlbyte);       //控制字
 356   1              check_ACK();
 357   1              if(askflag == 1)
 358   1              {
 359   2                      SystemError = 1;
 360   2                      return;
 361   2              }
 362   1      
 363   1          iic_start();                //重新发送开始命令
 364   1              IICSendByte(PCF8591_READ);      //控制字
 365   1              check_ACK();
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 7   

 366   1              if(askflag == 1)
 367   1              {
 368   2                      SystemError = 1;
 369   2                      return;
 370   2              }
 371   1               
 372   1          IICreceiveByte();   //空读一次，调整读顺序
 373   1          slave_ACK();        //收到一个字节后发送一个应答位
 374   1      
 375   1              while(i<4)
 376   1              {  
 377   2                receive_da=IICreceiveByte();
 378   2                receivebuf[i++]=receive_da;
 379   2                slave_ACK();       //收到一个字节后发送一个应答位
 380   2              }
 381   1              slave_NOACK();       //收到最后一个字节后发送一个非应答位
 382   1              iic_stop();
 383   1      }
 384          //-------------------------------------------------------------------
 385          // 函数名称： main
 386          // 函数功能： 主程序
 387          //-------------------------------------------------------------------
 388          main()
 389          {
 390   1          uchar i,l;
 391   1          delay(10);                 //延时
 392   1          lcd_init();                //初始化LCD             
 393   1              
 394   1          lcd_pos(0);                //设置显示位置为第一行的第1个字符
 395   1           i = 0;
 396   1          while(dis4[i] != '\0')
 397   1           {                         //显示字符
 398   2             lcd_wdat(dis4[i]);
 399   2             i++;
 400   2           }
 401   1      
 402   1          lcd_pos(0x40);             //设置显示位置为第二行第1个字符
 403   1           i = 0;
 404   1          while(dis5[i] != '\0')
 405   1           {
 406   2             lcd_wdat(dis5[i]);      //显示字符
 407   2             i++;
 408   2           }
 409   1              
 410   1        while(1)
 411   1        {
 412   2              iicInit();                    //I2C总线初始化
 413   2          ADC_PCF8591(0x04);
 414   2      
 415   2              if(SystemError == 1)      //有错误，重新来
 416   2                {
 417   3                      iicInit();                                //I2C总线初始化
 418   3                  ADC_PCF8591(0x04);
 419   3                 }   
 420   2              
 421   2              for(l=0;l<4;l++)        
 422   2               {
 423   3                show_value(receivebuf[0]); //显示通道0       
 424   3                  lcd_pos(0x02);             
 425   3              lcd_wdat(dis[2]);        //整数位显示
 426   3              lcd_pos(0x04);             
 427   3              lcd_wdat(dis[1]);        //第一位小数显示 
C51 COMPILER V8.02   PCF8591                                                               05/18/2013 13:51:34 PAGE 8   

 428   3              lcd_pos(0x05);             
 429   3              lcd_wdat(dis[0]);        //第二位小数显示
 430   3      
 431   3            show_value(receivebuf[1]); //显示通道1     
 432   3                  lcd_pos(0x0b);             
 433   3              lcd_wdat(dis[2]);        //整数位显示
 434   3              lcd_pos(0x0d);             
 435   3              lcd_wdat(dis[1]);        //第一位小数显示 
 436   3              lcd_pos(0x0e);             
 437   3              lcd_wdat(dis[0]);        //第二位小数显示
 438   3      
 439   3                show_value(receivebuf[2]); //显示通道2                 
 440   3                  lcd_pos(0x42);             
 441   3              lcd_wdat(dis[2]);        //整数位显示
 442   3              lcd_pos(0x44);             
 443   3              lcd_wdat(dis[1]);        //第一位小数显示 
 444   3              lcd_pos(0x45);             
 445   3              lcd_wdat(dis[0]);        //第二位小数显示
 446   3      
 447   3            show_value(receivebuf[3]); //显示通道3     
 448   3                  lcd_pos(0x4b);             
 449   3              lcd_wdat(dis[2]);        //整数位显示
 450   3              lcd_pos(0x4d);              
 451   3              lcd_wdat(dis[1]);        //第一位小数显示 
 452   3              lcd_pos(0x4e);             
 453   3              lcd_wdat(dis[0]);        //第二位小数显示
 454   3      
 455   3                iicInit();                  //I2C总线初始化  
 456   3            DAC_PCF8591(0x40,receivebuf[0]); //D/A输出
 457   3      
 458   3                      if(SystemError == 1)      //有错误，重新来
 459   3                  {
 460   4                       iicInit();                               //I2C总线初始化
 461   4                       DAC_PCF8591(0x40,receivebuf[0]); //D/A输出
 462   4                  }           
 463   3      
 464   3            //delay(50);                       //延时
 465   3               }
 466   2      
 467   2         }
 468   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    861    ----
   CONSTANT SIZE    =     34    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      8       1
   IDATA SIZE       =      4       4
   BIT SIZE         =      2       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
