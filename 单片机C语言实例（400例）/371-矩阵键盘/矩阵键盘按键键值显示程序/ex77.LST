C51 COMPILER V8.18   EX77                                                                  01/04/2010 13:10:14 PAGE 1   


C51 COMPILER V8.18, COMPILATION OF MODULE EX77
OBJECT MODULE PLACED IN ex77.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE ex77.c BROWSE DEBUG OBJECTEXTEND

line level    source

   1          //矩阵式键盘按键值的数码管显示实验
   2          #include<reg52.h>   //包含51单片机寄存器定义的头文件
   3          sbit P14=P1^4;      //将P14位定义为P1.4引脚
   4          sbit P15=P1^5;      //将P15位定义为P1.5引脚
   5          sbit P16=P1^6;      //将P16位定义为P1.6引脚
   6          sbit P17=P1^7;      //将P17位定义为P1.7引脚
   7          unsigned char code Tab[ ]={0xc0,0xf9,0xa4,0xb0,0x99,0x92,0x82,0xf8,0x80,0x90};    //数字0~9的段码
   8          unsigned char keyval;    //定义变量储存按键值
   9          /**************************************************************
  10          函数功能：数码管动态扫描延时
  11          **************************************************************/
  12          void led_delay(void)     
  13           {
  14   1         unsigned char j;
  15   1              for(j=0;j<200;j++)
  16   1               ;
  17   1        }
  18          /**************************************************************
  19          函数功能：按键值的数码管显示子程序
  20          **************************************************************/
  21           void display(unsigned char k)
  22          {
  23   1         P2=0xbf;            //点亮数码管DS6
  24   1         P0=Tab[k/10];       //显示十位 
  25   1         led_delay();        //动态扫描延时 
  26   1          led_delay();        //动态扫描延时
  27   1               led_delay();        //动态扫描延时  
  28   1         P0=0xff;
  29   1         P2=0x7f;            //点亮数码管DS7
  30   1         P0=Tab[k%10];       //显示个位 
  31   1              led_delay();       //动态扫描延时 
  32   1               led_delay();        //动态扫描延时 
  33   1                led_delay();        //动态扫描延时 
  34   1              P0=0xff;  
  35   1       }
  36          /**************************************************************
  37          函数功能：软件延时子程序
  38          **************************************************************/
  39           void delay20ms(void)   
  40          {
  41   1         unsigned char i,j;
  42   1              for(i=0;i<100;i++)
  43   1               for(j=0;j<60;j++)
  44   1                 ;
  45   1       }
  46          /**************************************************************
  47          函数功能：主函数
  48          **************************************************************/ 
  49           void main(void)
  50           {
  51   1         EA=1;                  //开总中断
  52   1              ET0=1;                 //定时器T0中断允许         
  53   1              TMOD=0x01;            //使用定时器T0的模式1
  54   1              TH0=(65536-500)/256;  //定时器T0的高8位赋初值
  55   1              TL0=(65536-500)%256;  //定时器T0的高8位赋初值
C51 COMPILER V8.18   EX77                                                                  01/04/2010 13:10:14 PAGE 2   

  56   1              TR0=1;                //启动定时器T0
  57   1              keyval=0x00;          //按键值初始化为0
  58   1                 
  59   1              while(1)                //无限循环
  60   1                      {
  61   2                        display(keyval);   //调用按键值的数码管显示子程序
  62   2                         led_delay();        //动态扫描延时 
  63   2                      }
  64   1      
  65   1      }
  66          /**************************************************************
  67          函数功能：定时器0的中断服务子程序，进行键盘扫描，判断键位
  68          **************************************************************/ 
  69            void time0_interserve(void) interrupt 1 using 1    //定时器T0的中断编号为1，使用第一组寄存器
  70            {
  71   1           TR0=0;                  //关闭定时器T0
  72   1           P1=0xf0;                 //所有行线置为低电平“0”，所有列线置为高电平“1”
  73   1                if((P1&0xf0)!=0xf0)      //列线中有一位为低电平“0”，说明有键按下
  74   1                   delay20ms();           //延时一段时间、软件消抖
  75   1                if((P1&0xf0)!=0xf0)      //确实有键按下
  76   1                  {
  77   2                     P1=0xfe;             //第一行置为低电平“0”（P1.0输出低电平“0”）
  78   2                     if(P14==0)           //如果检测到接P1.4引脚的列线为低电平“0”
  79   2                   keyval=1;            //可判断是S1键被按下
  80   2                 if(P15==0)             //如果检测到接P1.5引脚的列线为低电平“0”
  81   2                   keyval=2;            //可判断是S2键被按下
  82   2                 if(P16==0)             //如果检测到接P1.6引脚的列线为低电平“0”
  83   2                   keyval=3;            //可判断是S3键被按下
  84   2                 if(P17==0)            //如果检测到接P1.7引脚的列线为低电平“0”
  85   2                   keyval=4;           //可判断是S4键被按下
  86   2      
  87   2                 P1=0xfd;             //第二行置为低电平“0”（P1.1输出低电平“0”）
  88   2                    if(P14==0)           //如果检测到接P1.4引脚的列线为低电平“0”
  89   2                   keyval=5;            //可判断是S5键被按下
  90   2                 if(P15==0)             //如果检测到接P1.5引脚的列线为低电平“0”
  91   2                   keyval=6;            //可判断是S6键被按下
  92   2                 if(P16==0)             //如果检测到接P1.6引脚的列线为低电平“0”
  93   2                   keyval=7;            //可判断是S7键被按下
  94   2                 if(P17==0)            //如果检测到接P1.7引脚的列线为低电平“0”
  95   2                   keyval=8;           //可判断是S8键被按下
  96   2                      
  97   2                 P1=0xfb;             //第三行置为低电平“0”（P1.2输出低电平“0”）
  98   2                  if(P14==0)          //如果检测到接P1.4引脚的列线为低电平“0”
  99   2                   keyval=9;          //可判断是S9键被按下
 100   2                 if(P15==0)           //如果检测到接P1.5引脚的列线为低电平“0”
 101   2                   keyval=10;         //可判断是S10键被按下
 102   2                 if(P16==0)          //如果检测到接P1.6引脚的列线为低电平“0”
 103   2                   keyval=11;        //可判断是S11键被按下
 104   2                 if(P17==0)          //如果检测到接P1.7引脚的列线为低电平“0”
 105   2                   keyval=12;        //可判断是S12键被按下
 106   2      
 107   2                 P1=0xf7;             //第四行置为低电平“0”（P1.3输出低电平“0”）
 108   2                  if(P14==0)          //如果检测到接P1.4引脚的列线为低电平“0”
 109   2                   keyval=13;          //可判断是S13键被按下
 110   2                 if(P15==0)           //如果检测到接P1.5引脚的列线为低电平“0”
 111   2                   keyval=14;         //可判断是S14键被按下
 112   2                 if(P16==0)          //如果检测到接P1.6引脚的列线为低电平“0”
 113   2                   keyval=15;        //可判断是S15键被按下
 114   2                 if(P17==0)          //如果检测到接P1.7引脚的列线为低电平“0”
 115   2                   keyval=16;        //可判断是S16键被按下
 116   2             }
 117   1           TR0=1;                    //开启定时器T0
C51 COMPILER V8.18   EX77                                                                  01/04/2010 13:10:14 PAGE 3   

 118   1           TH0=(65536-500)/256;  //定时器T0的高8位赋初值
 119   1                TL0=(65536-500)%256;  //定时器T0的高8位赋初值          
 120   1       }
 121          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    245    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =      1    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
